/*
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Copyright 2022 GIP SmartMercial GmbH, Germany
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 */

package com.gip.juno.ws.handler;

import java.lang.reflect.Method;
import java.math.BigInteger;
import java.rmi.RemoteException;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.log4j.Logger;

import com.gip.juno.ws.enums.LocationSchema;
import com.gip.juno.ws.enums.Pk;
import com.gip.juno.ws.exceptions.DPPWebserviceIllegalArgumentException;
import com.gip.juno.ws.exceptions.DPPWebserviceReflectionException;
import com.gip.juno.ws.tools.ColInfo;
import com.gip.juno.ws.tools.DBTableInfo;
import com.gip.juno.ws.tools.ResultSetReaderForLocation;
import com.gip.juno.ws.tools.Constants;
import com.gip.xyna.utils.db.ResultSetReader;

class DBReaderMetaData {
  ColInfo col;
  Method setter;
  int rsColnum = 0;
}

/**
 * Class that translates java beans (for example as generated by axis to access soap messages xml)
 * into generic datastructures.
 * Uses java reflection api.
 * Provides functionality to invoke getter and setter methods,
 * as well as to find those getter and setter methods by their property name.
 */
public class ReflectionTools<T> {

  public static final String _locationXmlName = Constants.standort;

  public static class DBReader<T> implements ResultSetReader<T> {
    protected Class<?> _resultClass;
    protected DBTableInfo _table;
    protected List<String> _columns;
    protected ReflectionTools<T> _reflection;
    protected Logger _logger;
    protected List<DBReaderMetaData> _metaData = null;
    public DBReader(DBTableInfo table, T ref, Logger logger) {
      _resultClass = (Class<?>) ref.getClass();
      _table = table;
      _columns = table.getColumnNames();
      _reflection = new ReflectionTools<T>(ref);
      _logger = logger;
    }
    public T read(ResultSet rs) throws SQLException {
      try {
        if (_metaData == null) {
          init(rs);
        }
        //T ret = (T) _resultClass.newInstance();
        T ret = initRowInstance();
        for (DBReaderMetaData colMeta : _metaData) {
          String val = rs.getString(colMeta.rsColnum);

          val = ValueAdapter.adaptValueFromDB(colMeta.col, val, _table.getSchema(), _logger);
          _reflection.callStringSetter(ret, colMeta.setter, val);
        }
        return ret;
      } catch (Exception e) {
        _logger.error(e);
        throw new SQLException(e);
      }
    }
    @SuppressWarnings("unchecked")
    protected T initRowInstance() throws InstantiationException, IllegalAccessException {
      T ret = (T) _resultClass.newInstance();
      return ret;
    }
    protected void init(ResultSet rs) throws SQLException {
      ResultSetMetaData rsmeta = rs.getMetaData();

      _metaData = new ArrayList<DBReaderMetaData>();
      for (String infoname : _columns) {
        try {
          ColInfo col = _table.getColumns().get(infoname);
          if (col.isSetByQuery) {
            DBReaderMetaData readerMeta = new DBReaderMetaData();
            Method setter = _reflection.getStringSetter(infoname);
            if (!col.lookupCol.equals("")) {
              int rsColnum = getRsColnum(col.dbname, rsmeta);
              readerMeta.rsColnum = rsColnum;
            } else {
              int rsColnum = getRsColnum(infoname, rsmeta);
              readerMeta.rsColnum = rsColnum;
            }
            readerMeta.col = col;
            readerMeta.setter = setter;
            _metaData.add(readerMeta);
          }
        } catch (Exception e) {
          _logger.error(e);
          throw new SQLException(e);
        }
      }
    }
    protected int getRsColnum(String infoname, ResultSetMetaData rsmeta) throws SQLException {
      for (int i=1; i <= rsmeta.getColumnCount(); i++) {
        String colnameMeta = rsmeta.getColumnName(i);
        if ((colnameMeta == null) || (colnameMeta.trim().equals(""))) {
          throw new SQLException("A column name is missing in result set.");
        }
        if (infoname.toLowerCase().equals(colnameMeta.toLowerCase())) {
          return i;
        }
      }
      throw new SQLException("Unable to adapt column name:" + infoname);
    }
  }

  public static class ReaderForServiceLocation<T> extends DBReader<T> implements ResultSetReaderForLocation<T> {
    private String _location;
    public ReaderForServiceLocation(DBTableInfo table, T ref, String location, Logger logger) {
      super(table, ref, logger);
      if (location != null) {
        setLocation(location);
      } else {
        setLocation("unknown");
      }
    }
    @SuppressWarnings("unchecked")
    protected T initRowInstance() throws InstantiationException, IllegalAccessException {
      T ret = (T) _resultClass.newInstance();
      try {
        Method setter = _reflection.getStringSetter(_reflection._locationXmlName);
        _reflection.callStringSetter(ret, setter, _location);
      } catch (Exception e) {
        throw new InstantiationException("Reflection Error in initialising location name.");
      }
      return ret;
    }
    public String getLocation() {
      return _location;
    }
    public void setLocation(String location) {
      _location = location;
    }
  }


  private T _ref;
  private Class<?> _beanClass;
  //private Logger _logger;

  public ReflectionTools(T ref) {
    _ref = ref;
    _beanClass = ref.getClass();
  }

  public ResultSetReaderForLocation<T> createResultSetReaderForLocation(DBTableInfo table,
        LocationSchema schema, String location, Logger logger) {

    if (schema == LocationSchema.service) {
      return new ReaderForServiceLocation<T>(table, _ref, location, logger);
    }
    return null;
  }

  private String getColValue(ResultSet rs, String colname, DBTableInfo table, Logger logger) throws SQLException {
    String ret = ValueAdapter.getColValueDBToGui(rs, table, colname, logger);
    return ret;
  }

  public String getLocationValue(T input) throws RemoteException {
    Method getter = getStringGetter(_locationXmlName);
    String ret = callStringGetter(input, getter);
    return ret;
  }

  public TreeMap<String, String> getRowMap(DBTableInfo table, T row, Logger logger) throws java.rmi.RemoteException {
    TreeMap<String, String> map = new TreeMap<String, String>();
    List<String> columns = table.getColumnNames();
    for (String colname : columns) {
      Method getter = getStringGetter(colname);
      String val = callStringGetter(row, getter);
      if (val == null) {
        val = "";
      }
      addMapValue(map, colname, val, table, logger);
    }
    logMap(map, logger);
    return map;
  }


  public TreeMap<String, String> getRowMapNonPkValuesEmpty(DBTableInfo table, T row, Logger logger)
         throws java.rmi.RemoteException {
    TreeMap<String, String> map = new TreeMap<String, String>();
    Map<String, ColInfo> columns = table.getColumns();
    for (Map.Entry<String, ColInfo> entry : columns.entrySet()) {
      String colname = entry.getKey();
      String val = null;
      if (entry.getValue().pk == Pk.True) {
        Method getter = getStringGetter(colname);
        val = callStringGetter(row, getter);
      }
      if (val == null) {
        val = "";
      }
      addMapValue(map, colname, val, table, logger);
    }
    logMap(map, logger);
    return map;
  }


  public TreeMap<String, String> getRowMapPkColsOnly(DBTableInfo table, T row, Logger logger)
         throws java.rmi.RemoteException {
    TreeMap<String, String> map = new TreeMap<String, String>();
    Map<String, ColInfo> columns = table.getColumns();
    for (Map.Entry<String, ColInfo> entry : columns.entrySet()) {
      String colname = entry.getKey();
      String val = null;
      if (entry.getValue().pk != Pk.True) {
        continue;
      }
      Method getter = getStringGetter(colname);
      val = callStringGetter(row, getter);
      if (val == null) {
        val = "";
      }
      addMapValue(map, colname, val, table, logger);
    }
    logMap(map, logger);
    return map;
  }


  private void logMap(Map<String, String> map, Logger logger) {
    StringBuilder ret = new StringBuilder(" Row Map : { ");
    for (Map.Entry<String, String> entry : map.entrySet()) {
      ret.append("{ " + entry.getKey() + " : " + entry.getValue() + " } ");
    }
    ret.append(" }");
    logger.info(ret.toString());
  }

  private void addMapValue(Map<String, String> map, String key, String value, DBTableInfo table, Logger logger)
        throws RemoteException {
    ValueAdapter.setColValueGuiToDBInMap(map, key, table, value, logger);
  }


  public Method getStringGetter(String propname) throws RemoteException {
    String methodname = "get" + propname;
    try {
      Method method = _beanClass.getMethod(methodname, (Class<?>[]) null);
      if (method.getReturnType() != String.class) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect return type");
      }
      if (method.getParameterTypes().length != 0) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect number of parameters");
      }
      return method;
    } catch (RemoteException e) {
      throw e;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Method name not found", e);
    }
  }

  public Method getBooleanGetter(String propname) throws RemoteException {
    String methodname = "" + propname;
    try {
      Method method = _beanClass.getMethod(methodname, (Class<?>[]) null);
      if (method.getReturnType() != Boolean.TYPE) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect return type");
      }
      if (method.getParameterTypes().length != 0) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect number of parameters");
      }
      return method;
    } catch (RemoteException e) {
      throw e;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Method name not found", e);
    }
  }

  public Method getBigIntegerGetter(String propname) throws RemoteException {
    String methodname = "get" + propname;
    try {
      Method method = _beanClass.getMethod(methodname, (Class<?>[]) null);
      if (method.getReturnType() != BigInteger.class) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect return type");
      }
      if (method.getParameterTypes().length != 0) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect number of parameters");
      }
      return method;
    } catch (RemoteException e) {
      throw e;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Method name not found", e);
    }
  }

  public String callStringGetter(T bean, Method getter) throws RemoteException {
    try {
      String val = (String) getter.invoke(bean);
      return val;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Error while calling reflection method", e);
    }
  }

  public boolean callBooleanGetter(T bean, Method getter) throws RemoteException {
    try {
      Boolean val = (Boolean) getter.invoke(bean);
      return val.booleanValue();
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Error while calling reflection method", e);
    }
  }

  public String callBigIntegerGetter(T bean, Method getter) throws RemoteException {
    try {
      String val = (String) getter.invoke(bean);
      return val;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Error while calling reflection method", e);
    }
  }

  public Method getStringSetter(String propname) throws RemoteException {
    String methodname = "set" + propname;
    try {
      Method method = _beanClass.getMethod(methodname, String.class);
      if (method.getReturnType() != Void.TYPE) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect return type");
      }
      Class<?>[] params = method.getParameterTypes();
      if (params.length != 1) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect number of parameters");
      }
      if (params[0] != String.class) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect parameter type");
      }
      return method;
    } catch (RemoteException e) {
      throw e;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Method name not found", e);
    }
  }

  public Method getBooleanSetter(String propname) throws RemoteException {
    String methodname = "set" + propname;
    try {
      Method method = _beanClass.getMethod(methodname, Boolean.TYPE);
      if (method.getReturnType() != Void.TYPE) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect return type");
      }
      Class<?>[] params = method.getParameterTypes();
      if (params.length != 1) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect number of parameters");
      }
      if (params[0] != Boolean.TYPE) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect parameter type");
      }
      return method;
    } catch (RemoteException e) {
      throw e;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Method name not found", e);
    }
  }

  public Method getBigIntegerSetter(String propname) throws RemoteException {
    String methodname = "set" + propname;
    try {
      Method method = _beanClass.getMethod(methodname, BigInteger.class);
      if (method.getReturnType() != Void.TYPE) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect return type");
      }
      Class<?>[] params = method.getParameterTypes();
      if (params.length != 1) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect number of parameters");
      }
      if (params[0] != BigInteger.class) {
        throw new DPPWebserviceReflectionException("Reflection method has incorrect parameter type");
      }
      return method;
    } catch (RemoteException e) {
      throw e;
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Method name not found", e);
    }
  }

  public void callStringSetter(T bean, Method setter, String val) throws RemoteException {
    try {
      setter.invoke(bean, val);
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Error while calling reflection method", e);
    }
  }

  public void callBooleanSetter(T bean, Method setter, boolean val) throws RemoteException {
    try {
      setter.invoke(bean, val);
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Error while calling reflection method", e);
    }
  }

  public void callBigIntegerSetter(T bean, Method setter, BigInteger val) throws RemoteException {
    try {
      setter.invoke(bean, val);
    } catch (Exception e) {
      throw new DPPWebserviceReflectionException("Error while calling reflection method", e);
    }
  }
}
